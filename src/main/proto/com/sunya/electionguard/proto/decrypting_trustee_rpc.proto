syntax = "proto3";

import "com/sunya/electionguard/proto/common.proto";
import "google/protobuf/empty.proto";

option java_package = "com.sunya.electionguard.proto";
option java_outer_classname = "DecryptingTrusteeProto";

service DecryptingTrusteeService {
  rpc compensatedDecrypt (CompensatedDecryptionRequest) returns (CompensatedDecryptionResponse) {}
  rpc partialDecrypt (DecryptionRequest) returns (DecryptionResponse) {}
}

//   Optional<DecryptionProofTuple> compensate_decrypt(
//          String missing_guardian_id,
//          ElGamal.Ciphertext elgamal,
//          Group.ElementModQ extended_base_hash,
//          @Nullable Group.ElementModQ nonce_seed) {

//   DecryptionProofTuple partially_decrypt(ElGamal.Ciphertext elgamal, Group.ElementModQ extended_base_hash, @Nullable Group.ElementModQ nonce_seed) {

message CompensatedDecryptionRequest {
  // The text to decrypt.
  ElGamalCiphertext text = 1;
  // The election extended_base_hash.
  ElementModQ extended_base_hash = 2; // LOOK could send once ?
  // The Id of the guardian thats missing, used only for compensatedDecrypt.
  string missing_guardian_id = 3;
}

message CompensatedDecryptionResponse {
  RemoteError error = 1; // non empty on error
  ElementModP decryption = 2;
  ChaumPedersenProof proof = 3;
  ElementModP recoveryPublicKey = 4;
}

message DecryptionRequest {
  // The text to decrypt.
  ElGamalCiphertext text = 1;
  // The election extended_base_hash.
  ElementModQ extended_base_hash = 2; // LOOK could send once ?
}

message DecryptionResponse {
  RemoteError error = 1; // non empty on error
  ElementModP decryption = 2;
  ChaumPedersenProof proof = 3;
}

//   Optional<Group.ElementModP> recovery_public_key_for(String missing_guardian_id) {

message RecoverPublicKeyRequest {
  string guardian_id = 1;
}

message RecoverPublicKeyResponse {
  RemoteError error = 1; // non empty on error
  // The Id of the guardian that generated this backup.
  ElementModP recovered_key = 2;
}

message PingResponse {
  bool ok = 1;
}



