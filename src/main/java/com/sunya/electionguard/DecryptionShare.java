package com.sunya.electionguard;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static com.sunya.electionguard.Group.*;

class DecryptionShare {

  /** A compensated fragment of a Guardian's Partial Decryption of a selection generated by an available guardian. */
  static class CiphertextCompensatedDecryptionSelection extends ElectionObjectBase {
    final String guardian_id; // The Available Guardian that this share belongs to
    final String missing_guardian_id; // The Missing Guardian for whom this share is calculated on behalf of

    final ElementModQ description_hash; //  The SelectionDescription hash

    final ElementModP share; // The Share of the decryption of a selection. `M_{i,l} in the spec`
    final ElementModP recovery_key; // The Recovery Public Key for the missing_guardian that corresponds to the available guardian's share of the secret
    final ChaumPedersen.ChaumPedersenProof proof; // The Proof that the share was decrypted correctly

    public CiphertextCompensatedDecryptionSelection(String objectId, String guardian_id, String missing_guardian_id,
              ElementModQ description_hash, ElementModP share, ElementModP recovery_key,
              ChaumPedersen.ChaumPedersenProof proof) {
      super(objectId);
      this.guardian_id = guardian_id;
      this.missing_guardian_id = missing_guardian_id;
      this.description_hash = description_hash;
      this.share = share;
      this.recovery_key = recovery_key;
      this.proof = proof;
    }
  }

  /**
   *     A Guardian's Partial Decryption of a selection.  A CiphertextDecryptionSelection
   *     can be generated by a guardian directly, or it can be compensated for by a quoprum of guardians
   *
   *     When the guardian generates this share directly, the `proof` field is populated with
   *     a `chaumPedersen` proof that the decryption share was generated correctly.
   *
   *     When the share is generated on behalf of this guardian by other guardians, the `recovered_parts`
   *     collection is populated with the `CiphertextCompensatedDecryptionSelection` objects generated
   *     by each available guardian.
   */
  static class CiphertextDecryptionSelection extends ElectionObjectBase {
    /** The Available Guardian that this share belongs to */
    final String guardian_id;

      /** The SelectionDescription hash. */
    final ElementModQ description_hash;

    /** The Share of the decryption of a selection. `M_i` in the spec. */
    final ElementModP share;

    /**     The Proof that the share was decrypted correctly, if the guardian was available for decryption */
    final Optional<ChaumPedersen.ChaumPedersenProof> proof;

      /** the recovered parts of the dectyption provided by available guardians, if the guardian was missing from decryption. */
    final Optional<Map<String, CiphertextCompensatedDecryptionSelection>> recovered_parts;

    public CiphertextDecryptionSelection(String objectId, String guardian_id, Group.ElementModQ description_hash,
               Group.ElementModP share,
               Optional<ChaumPedersen.ChaumPedersenProof> proof,
               Optional<Map<String, CiphertextCompensatedDecryptionSelection>> recovered_parts) {
      super(objectId);
      this.guardian_id = guardian_id;
      this.description_hash = description_hash;
      this.share = share;
      this.proof = proof;
      this.recovered_parts = recovered_parts;
    }

    /**
     *         Verify that this CiphertextDecryptionSelection is valid for a
     *         specific ElGamal key pair, public key, and election context.
     *
     *         :param message: the `ElGamalCiphertext` to compare
     *         :param election_public_key: the `ElementModP Election Public Key for the Guardian
     *         :param extended_base_hash: The `ElementModQ` election extended base hash.
     * @return
     */
    boolean is_valid(ElGamal.Ciphertext message, ElementModP election_public_key, ElementModQ extended_base_hash) {
      // verify we have a proof or recovered parts
      if (!this.proof.isPresent() && !this.recovered_parts.isPresent()) {
        // f"CiphertextDecryptionSelection is_valid failed for guardian: {self.guardian_id} selection: {self.object_id} with missing data"
        return false;
      }

      if (this.proof.isPresent() && this.recovered_parts.isPresent()) {
        // f"CiphertextDecryptionSelection is_valid failed for guardian: {self.guardian_id} selection: {self.object_id} cannot have proof and recovery"
        return false;
      }

      if (this.proof.isPresent()) {
        ChaumPedersen.ChaumPedersenProof proof = this.proof.get();
        if (!proof.is_valid(message, election_public_key, this.share, extended_base_hash)) {
          // f"CiphertextDecryptionSelection is_valid failed for guardian: {self.guardian_id} selection: {self.object_id} with invalid proof"
          return false;
        }
      }

      if (this.recovered_parts.isPresent()) {
        Map<String, CiphertextCompensatedDecryptionSelection> recovered = this.recovered_parts.get();
        for (CiphertextCompensatedDecryptionSelection part : recovered.values()) {
          if (!part.proof.is_valid(message, part.recovery_key, part.share, extended_base_hash)) {
            // f"CiphertextDecryptionSelection is_valid failed for guardian: {self.guardian_id} selection: {self.object_id} with invalid partial proof"
            return false;
          }
        }
      }
      return true;
    }
  }

  /**     A Guardian's Partial Decryption of a contest. */
   static class CiphertextDecryptionContest extends ElectionObjectBase {
    final String guardian_id; // The Available Guardian that this share belongs to
    final ElementModQ description_hash; // The ContestDescription Hash
    final Map<String, CiphertextDecryptionSelection> selections; // the collection of decryption shares for this contest's selections

    public CiphertextDecryptionContest(String objectId, String guardian_id, ElementModQ description_hash, Map<String, CiphertextDecryptionSelection> selections) {
      super(objectId);
      this.guardian_id = guardian_id;
      this.description_hash = description_hash;
      this.selections = selections;
    }
  }

  /** A Guardian's Partial Decryption Share of a specific ballot (e.g. of a spoiled ballot) */
  static class BallotDecryptionShare {
    final String guardian_id; // The Available Guardian that this share belongs to
    final ElementModP public_key; // The election public key for the guardian
    final String ballot_id; // The Ballot Id that this Decryption Share belongs to
    final Map<String,CiphertextDecryptionContest> contests; //  The collection of all contests in the ballot

    public BallotDecryptionShare(String guardian_id, ElementModP public_key, String ballot_id, Map<String, CiphertextDecryptionContest> contests) {
      this.guardian_id = guardian_id;
      this.public_key = public_key;
      this.ballot_id = ballot_id;
      this.contests = contests;
    }
  }

  /**     A Guardian's Partial Decryption Share of an election tally. */
   static class TallyDecryptionShare {
    final String guardian_id; // The Available Guardian that this share belongs to
    final ElementModP public_key; // The election public key for the guardian
    final Map<String, CiphertextDecryptionContest> contests; // The collection of decryption shares for all contests in the election
    final Map<String, BallotDecryptionShare> spoiled_ballots; // The collection of decryption shares for all spoiled ballots in the election

    public TallyDecryptionShare(String guardian_id, ElementModP public_key,
           Map<String, CiphertextDecryptionContest> contests, Map<String, BallotDecryptionShare> spoiled_ballots) {
      this.guardian_id = guardian_id;
      this.public_key = public_key;
      this.contests = contests;
      this.spoiled_ballots = spoiled_ballots;
    }
  }

  static class Tuple2 {
    final ElementModP public_key;
    final CiphertextDecryptionSelection decryption;

    public Tuple2(ElementModP public_key, CiphertextDecryptionSelection decryption) {
      this.public_key = public_key;
      this.decryption = decryption;
    }
  }

  /** Get all of the cast shares for a specific selection */
   static Map<String, Tuple2> get_tally_shares_for_selection(String selection_id, Map<String, TallyDecryptionShare> shares) {
     HashMap<String, Tuple2> cast_shares = new HashMap<>();
     for (TallyDecryptionShare share : shares.values()) {
       for (CiphertextDecryptionContest contest : share.contests.values()) {
         for (CiphertextDecryptionSelection selection : contest.selections.values()) {
           if (selection.object_id.equals(selection_id)) {
             cast_shares.put(share.guardian_id, new Tuple2(share.public_key, selection));
           }
         }
       }
     }
     return cast_shares;
   }

   /** Get the ballot shares for a given selection, in the context of a specific ballot. */
  static Map<String, Tuple2> get_ballot_shares_for_selection(String selection_id, Map<String, BallotDecryptionShare> shares) {
    HashMap<String, Tuple2> ballot_shares = new HashMap<>();
    for (BallotDecryptionShare ballot_share : shares.values()) {
      for (CiphertextDecryptionContest contest_share : ballot_share.contests.values()) {
        for (CiphertextDecryptionSelection selection_share : contest_share.selections.values()) {
          if (selection_share.object_id .equals(selection_id)) {
            ballot_shares.put(ballot_share.guardian_id, new Tuple2(ballot_share.public_key, selection_share));
          }
        }
      }
    }
    return ballot_shares;
  }
}
