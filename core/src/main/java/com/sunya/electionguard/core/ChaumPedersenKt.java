package com.sunya.electionguard.core;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.flogger.FluentLogger;
import com.sunya.electionguard.ChaumPedersen;
import com.sunya.electionguard.ElGamal;
import com.sunya.electionguard.Group;
import com.sunya.electionguard.Hash;
import com.sunya.electionguard.Nonces;

import javax.annotation.concurrent.Immutable;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;

import static com.sunya.electionguard.Group.ElementModQ;
import static com.sunya.electionguard.Group.ElementModP;

public class ChaumPedersenKt {
  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  /**
   * Proof that the ciphertext is a given constant.
   */
  public record ConstantChaumPedersenProofKnownNonce(
          GenericChaumPedersenProof proof,
          int constant
  ) {

    public boolean isValid(
            ElGamalKt.Ciphertext ciphertext,
            ElementModP publicKey,
            ElementModQ qbar,
            int expectedConstant) {

      ElementModQ constantQ = Group.negate_q(Group.int_to_q_unchecked(BigInteger.valueOf(this.constant)));
      return proof.isValid(
              Group.getPrimes().generatorP,
              ciphertext.pad(),
              publicKey,
              Group.mult_p(ciphertext.data(), Group.pow_p(publicKey, constantQ)),
              Arrays.asList(qbar, publicKey, ciphertext.pad(), ciphertext.data()),
              List.of(),
              true
      ) && (constant == expectedConstant);
    }
  }

  /**
   * Produces a proof that a given ElGamal encryption corresponds to a specific total value. This
   * requires the prover to know the nonce (the r behind the g^r).
   *
   * @param plaintext The total allowed votes (L in the spec)
   * @param nonce The aggregate nonce used creating the ElGamal ciphertext (r in the spec)
   * @param publicKey The ElGamal public key for the election
   * @param seed Used to generate other random values here
   * @param qbar The election extended base hash (Q')
   */
  public static ConstantChaumPedersenProofKnownNonce constantChaumPedersenProofKnownNonceOf(
          ElGamalKt.Ciphertext message,
          Integer plaintext,
          ElementModQ nonce,
          ElementModP publicKey,
          ElementModQ seed,
          ElementModQ qbar) {
    return new ConstantChaumPedersenProofKnownNonce(
            genericChaumPedersenProofOf(
                    Group.getPrimes().generatorP,
                    publicKey,
                    nonce,
                    seed,
                    List.of(qbar, message.pad(), message.data()),
                    List.of()
            ),
            plaintext
    );
  }

  /**
   * Produces a generic Chaum-Pedersen proof that two tuples share an exponent, i.e., that for (g,
   * g^x) and (h, h^x), it's the same value of x, but without revealing x. This generic proof can be
   * used as a building-block for many other proofs.
   *
   * There's no need for g^x and h^x in this particular computation.
   *
   * @param g Any element in P that can be generated by [GroupContext.gPowP]
   * @param h Any element in P that can be generated by [GroupContext.gPowP]
   * @param x secret key or sum of nonces
   * @param seed Used to randomize the generation of the Chaum-Pedersen proof.
   * @param hashHeader Optional additional values to include in the hash challenge computation hash.
   * @param hashFooter Optional additional values to include in the hash challenge computation hash.
   */
  public static GenericChaumPedersenProof genericChaumPedersenProofOf(
          ElementModP g,
          ElementModP h,  // A = G^r
          ElementModQ x,
          ElementModQ seed,
          List<Object> hashHeader,
          List<Object> hashFooter) {

    // The proof generates a random value w ∈ Z q , computes the commitments (a , b) = (g^w , A^w),
    // obtains the challenge value as c = H( Q̄, A, B, a, b, M)
    // and the response r = (w + c * s) mod q.
    // The proof is (a, b, c, r)

    ElementModQ w = new Nonces(seed, "generic-chaum-pedersen-proof").get(0);
    ElementModP a = Group.pow_p(g, w);
    ElementModP b = Group.pow_p(h, w);

    List<Object> hashElems = Lists.newArrayList();
    hashElems.addAll(hashHeader);
    hashElems.add(a);
    hashElems.add(b);
    hashElems.addAll(hashFooter);
    ElementModQ c = Hash.hash_elems(hashElems.toArray());
    ElementModQ r = Group.a_plus_bc_q(w, x, c);

    return new GenericChaumPedersenProof(c, r);
  }

  /**
   * General-purpose Chaum-Pedersen proof object, demonstrating that the prover knows the exponent `x`
   * for two tuples `(g, g^x)` and `(h, h^x)`, without revealing anything about `x`. This is used as a
   * component in other proofs.
   * (See [Chaum-Pedersen 1992](https://link.springer.com/chapter/10.1007/3-540-48071-4_7))
   *
   * @param c hash(a, b, and possibly other state) (aka challenge)
   * @param r w + xc (aka response)
   */
  public record GenericChaumPedersenProof(ElementModQ c, ElementModQ r) {

    public boolean isValid(
            ElGamalKt.Ciphertext ciphertext,
            ElementModP publicKey,
            ElementModP m,
            ElementModQ qbar) {

      return isValid(
              Group.getPrimes().generatorP,
              publicKey,
              ciphertext.pad(),
              m,
              Arrays.asList(qbar, publicKey, ciphertext.pad(), ciphertext.data()),
              Arrays.asList(m),
              true
      );
    }

    /**
     * Checks that this Chaum-Pedersen proof certifies that the prover knew an x, such that (g, g^x) and
     * (h, h^x) share the same exponent x, without revealing x. Part of the proof is a challenge
     * constant. By suppressing this check, "fake" proofs can be validated. Useful when doing
     * disjunctive proofs.
     *
     * @param g See above.
     * @param gx See above.
     * @param h See above.
     * @param hx See above.
     * @param hashHeader Optional additional values to include in the hash challenge computation hash
     * @param hashFooter Optional additional values to include in the hash challenge computation hash
     * @param checkC If false, the challenge constant is not verified. (default: true)
     * @return true if the proof is valid
     */
    public boolean isValid(
            ElementModP g,
            ElementModP gx, // Ki = public key
            ElementModP h, // pad
            ElementModP hx, // Mi = partial_decrypt = pad ^ si
            List<Object> hashHeader,
            List<Object> hashFooter,
            boolean checkC
    ) {
      return expand(g, gx, h, hx).isValid(g, gx, h, hx, hashHeader, hashFooter, checkC);
    }

    public ExpandedGenericChaumPedersenProof expand(
            ElementModP g,
            ElementModP gx,
            ElementModP h,
            ElementModP hx) {

      ElementModQ negC = Group.negate_q(c);
      ElementModP gr = Group.pow_p(g, r); // g^r = g^{w + xc}
      ElementModP hr = Group.pow_p(h, r); // h^r = h^{w + xc}
      ElementModP a = Group.mult_p(gr, Group.pow_p(gx, negC)); // cancelling out the xc, getting g^w
      ElementModP b = Group.mult_p(hr, Group.pow_p(hx, negC)); // cancelling out the xc, getting h^w
      return new ExpandedGenericChaumPedersenProof(a, b, c, r);
    }
  }

  public record ExpandedGenericChaumPedersenProof(
          ElementModP a,
          ElementModP b,
          ElementModQ c,
          ElementModQ r) {

    public boolean isValid(
            ElementModP g,
            ElementModP gx,
            ElementModP h,
            ElementModP hx,
            List<Object> hashHeader,
            List<Object> hashFooter,
            boolean checkC
    ) {

      boolean inBoundsG = g.is_valid_residue();
      boolean inBoundsGx = gx.is_valid_residue();
      boolean inBoundsH = h.is_valid_residue();
      boolean inBoundsHx = hx.is_valid_residue();

      // Hash.hash_elems(hash_header, A, B, a, b, m)
      List<Object> hashElems = Lists.newArrayList();
      hashElems.addAll(hashHeader);
      hashElems.add(a);
      hashElems.add(b);
      hashElems.addAll(hashFooter);
      boolean hashGood = !checkC || this.c.equals(Hash.hash_elems(hashElems.toArray()));
      boolean success = (hashGood && inBoundsG && inBoundsGx && inBoundsH && inBoundsHx);

      if (!success) {
        logger.atWarning().log(
                "Invalid generic Chaum-Pedersen proof: " +
                        " hashGood " + hashGood +
                        " inBoundsG " + inBoundsG +
                        " inBoundsGx " + inBoundsGx +
                        " inBoundsH " + inBoundsH +
                        " inBoundsHx " + inBoundsHx +
                        " %n");
      }
      return success;
    }
  }

  /**
   * Proof that the ciphertext is either zero or one. (See
   * [Cramer-Damgård-Schoenmakers 1994](https://www.iacr.org/cryptodb/data/paper.php?pubkey=1194))
   */
  @Immutable
  public record DisjunctiveChaumPedersenProofKnownNonce(
          GenericChaumPedersenProof proof0,
          GenericChaumPedersenProof proof1,
          ElementModQ c) {

    // 2.0
    public DisjunctiveChaumPedersenProofKnownNonce {
      Preconditions.checkNotNull(proof0);
      Preconditions.checkNotNull(proof1);
      Preconditions.checkNotNull(c);
    }

    // 1.0
    public DisjunctiveChaumPedersenProofKnownNonce(
            ChaumPedersen.DisjunctiveChaumPedersenProof ver1) {
      this(
              new GenericChaumPedersenProof(ver1.proof0.challenge, ver1.proof0.response),
              new GenericChaumPedersenProof(ver1.proof1.challenge, ver1.proof1.response),
              Preconditions.checkNotNull(ver1.challenge));
    }

    public boolean isValid(
            ElGamal.Ciphertext ciphertext,
            ElementModP publicKey,
            ElementModQ qbar) {

      ElementModP alpha = ciphertext.pad();
      ElementModP beta = ciphertext.data();

      boolean consistentC = Group.add_q(proof0.c, proof1.c).equals(c);
      ExpandedGenericChaumPedersenProof eproof0 =
              proof0.expand(
                      Group.getPrimes().generatorP,
                      ciphertext.pad(),
                      publicKey,
                      ciphertext.data()
              );
      ExpandedGenericChaumPedersenProof eproof1 =
              proof1.expand(
                      Group.getPrimes().generatorP,
                      ciphertext.pad(),
                      publicKey,
                      Group.div_p(ciphertext.data(), publicKey)
              );

      boolean validHash = c.equals(
              Hash.hash_elems(qbar, alpha, beta, eproof0.a(), eproof0.b(), eproof1.a(), eproof1.b()));

      boolean valid0 =
              eproof0.isValid(
                      Group.getPrimes().generatorP,
                      ciphertext.pad(),
                      publicKey,
                      ciphertext.data(),
                      List.of(qbar),
                      List.of(),
                      false
                      );

      boolean valid1 =
              eproof1.isValid(
                      Group.getPrimes().generatorP,
                      ciphertext.pad(),
                      publicKey,
                      Group.div_p(ciphertext.data(), publicKey),
                      List.of(qbar),
                      List.of(),
                      false
                      );

      // If valid0 or valid1 is false, this will already have been logged,
      // so we don't have to repeat it here.
      if (!consistentC || !validHash) {
        logger.atWarning().log(
        "Invalid commitments for disjunctive Chaum-Pedersen proof: " +
                        " consistentC " + consistentC +
                        " validHash " + validHash +
                        " valid0 " + valid0 +
                        " valid1 " + valid1);
      }

      return valid0 && valid1 && consistentC && validHash;
    }
  }

}